> 특정 조건을 만족시키는 데 필요한 최소량의 데이터만 처리하고 싶다.
⇒ 코틀린 시퀀스를 쇼트 서킷 함수와 함께 사용한다.
>

### 컬렉션 vs 시퀀스

- 컬렉션은 즉시 발생(Eager)
- 시퀀스는 지연 발생(lazy)
    - 지연 처리 방식은 데이터가 많거나 first 같은 쇼트 서킷 연산의 경우 도움이 된다.
    - 값을 찾았을 때 시퀀스를 종료한다.

컬렉션

```java
(100..200).map { it * 2 }
        .filter { it % 3 == 0 }
        .first()
// 100개 계산 -> 100개 계산

(100..200).map { it * 2 }
        .first { it % 3 == 0 }

// 100개 계산 -> (3개 계산 200 202 204)
```

시퀀스

```java
(100..200).asSequence()
        .map { println("doubling"); it *2 }
        .filter { println("filtering"); it % 3 == 0 }
        .first()

// doubling 100
// filtering 200
// doubling 101...

이렇게 6번밖에 수행을 안함!
```

- 시퀀스는 다음 원소로 진행하기 전에 완전한 전체 파이프라인에서 처리되기 때문에 수행하는 연산이 매우 적음!!
- map, filter같은 중간 연산은 시퀀스를 리턴