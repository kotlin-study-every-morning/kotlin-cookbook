### FP(Functional Programming)의 역사

일단 함수형 프로그래밍의 등장 배경을 보겠습니다.
일단 명령형 프로그래밍 기반에서 소프트웨어의 크기가 커졌습니다. 그래서 스파게티 코드를 유지 보수할 수가 없어졌습니다. 그래서 순수 함수로 문제를 해결하는 기법인 함수형 프로그래밍이라는 패러다임에 관심을 가지게 되었습니다.
**하지만** 함수형 프로그래밍은 객체지향이 유행하기 전부터 존재했었지만 최근 들어서야 **함수형 프로그래밍이 유행**하고 있다.
→ 현대 컴퓨터 시스템은 과거에 비해 **컴퓨터 자원들의 가격이 저렴해지고 멀티코어가 기본적으로 장착**되어 있고 성능이 좋게 나온다.
그리고 최근에는 머신러닝, 데이터 분석 등 **무겁고 시간이 오래 걸리는 작업**들이 많이 있다. 그리고 이 작업들을 효과적으로 시간을 단축시켜 수행하기 위해 컴퓨터 **멀티코어**라는 점을 이용해서 **병렬성을 이용**하는데 **함수형 프로그래밍은 병렬성 처리가 쉬워서 유행**하는것도 있다.

**동시성**
- **하나의 CPU 코어에서 멀티 스레드가 번갈아가며 실행하는 성질**
- 컨텍스트 스위칭, 비동기 처리

**병렬성**
- 멀티 작업을 위해 **멀티 코어에서 개별 스레드가 동시에 실행**하는 성질
- **여러 CPU에서 큰 하나의 테스크를 나누어서 실행**하는 측면

```python
# Sample 1
def square(x):
    return x * x

# Sample 2
def square(x):
    result = x * x # 가변 변수 result를 가지지만 함수 내부로 한정되며 외부로부터 참조하지 않음)
    return result

# main
print(square(5)) # 25
print(square(3)) # 9
print(square(5)) # 25
```

다음과 같이 x가 5이면 항상 y = 25임을 보장한다.
- 가변 객체를 참조하지 않아서 가능하다.
이러한 "함수"는 Side effect가 없는 즉 부작용이 없다고 한다.
또한 이렇게 부작용 없는 함수를 **"순수 함수"** (Pure function)라고 한다.

### 가변 데이터와 동기화

**여러 스레드에서 공유된 가변 데이터 구조**를 읽고 갱신할 때, **동시성 문제가 발생**할 수 있다. (변수가 예상치 못한 값을 가지는 문제점)
이러한 것을 **Thread Safe**하지 않다고 한다.
Thread Safe 하지 않다는 것은 동기화처리가 되어 있지 않아서, **멀티 스레드 환경에서 (자바는 멀티 프로세스가 아닌 멀티 스레드 방식으로 동작함) 예상치 못한 문제가 발생할 수 있다는 것**이다.
⇒ 잠금, synchronized

### 함수형 프로그래밍에서는?
- 별도의 여러 스레드에서 공유하는 가변 객체를 갖고 있지 않아서, 불변의 특징을 갖는다.

```python
# Sample 1
def square(x):
    return x * x

# Sample 2
def square(x):
    result = x * x # 가변 변수 result를 가지지만 함수 내부로 한정되며 외부로부터 참조하지 않음)
    return result

# main
print(square(5)) # 25
print(square(3)) # 9
print(square(5)) # 25
```

- 가변 데이터를 가지고 있지 않다.
- 별도의 동기화 처리를 해주지 않아도 된다.